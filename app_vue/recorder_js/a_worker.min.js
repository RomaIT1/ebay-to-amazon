!function(r, e) {
    "use strict";
    if ("function" == typeof define && define.amd)
        return define(["exports"], e);
    if ("object" == typeof exports)
        return e(exports);
    var t = r.mp3ParserLib;
    e(r.mp3ParserLib = {
        noConflict: function() {
            var e = r.mp3ParserLib;
            return r.mp3ParserLib = t,
            (this.noConflict = function() {
                return e
            }
            ).call()
        }
    })
}(this, function(u) {
    "use strict";
    var r, d = (r = [],
    function(e) {
        return r[0] = 128 == (128 & e) ? "1" : "0",
        r[1] = 64 == (64 & e) ? "1" : "0",
        r[2] = 32 == (32 & e) ? "1" : "0",
        r[3] = 16 == (16 & e) ? "1" : "0",
        r[4] = 8 == (8 & e) ? "1" : "0",
        r[5] = 4 == (4 & e) ? "1" : "0",
        r[6] = 2 == (2 & e) ? "1" : "0",
        r[7] = 1 == (1 & e) ? "1" : "0",
        r.join("")
    }
    );
    u.getFrameByteLength = function(e, r, t, n, i) {
        var a = u.sampleLengthMap[n][i]
          , o = t ? "11" === i ? 4 : 1 : 0
          , s = 1e3 * e / 8;
        return Math.floor(a * s / r + o)
    }
    ,
    u.getXingOffset = function(e, r) {
        var t = "11" === r;
        return "11" === e ? t ? 21 : 36 : t ? 13 : 21
    }
    ,
    u.v1l1Bitrates = {
        "0000": "free",
        "0001": 32,
        "0010": 64,
        "0011": 96,
        "0100": 128,
        "0101": 160,
        "0110": 192,
        "0111": 224,
        1e3: 256,
        1001: 288,
        1010: 320,
        1011: 352,
        1100: 384,
        1101: 416,
        1110: 448,
        1111: "bad"
    },
    u.v1l2Bitrates = {
        "0000": "free",
        "0001": 32,
        "0010": 48,
        "0011": 56,
        "0100": 64,
        "0101": 80,
        "0110": 96,
        "0111": 112,
        1e3: 128,
        1001: 160,
        1010: 192,
        1011: 224,
        1100: 256,
        1101: 320,
        1110: 384,
        1111: "bad"
    },
    u.v1l3Bitrates = {
        "0000": "free",
        "0001": 32,
        "0010": 40,
        "0011": 48,
        "0100": 56,
        "0101": 64,
        "0110": 80,
        "0111": 96,
        1e3: 112,
        1001: 128,
        1010: 160,
        1011: 192,
        1100: 224,
        1101: 256,
        1110: 320,
        1111: "bad"
    },
    u.v2l1Bitrates = {
        "0000": "free",
        "0001": 32,
        "0010": 48,
        "0011": 56,
        "0100": 64,
        "0101": 80,
        "0110": 96,
        "0111": 112,
        1e3: 128,
        1001: 144,
        1010: 160,
        1011: 176,
        1100: 192,
        1101: 224,
        1110: 256,
        1111: "bad"
    },
    u.v2l2Bitrates = {
        "0000": "free",
        "0001": 8,
        "0010": 16,
        "0011": 24,
        "0100": 32,
        "0101": 40,
        "0110": 48,
        "0111": 56,
        1e3: 64,
        1001: 80,
        1010: 96,
        1011: 112,
        1100: 128,
        1101: 144,
        1110: 160,
        1111: "bad"
    },
    u.v2l3Bitrates = u.v2l2Bitrates,
    u.v1SamplingRates = {
        "00": 44100,
        "01": 48e3,
        10: 32e3,
        11: "reserved"
    },
    u.v2SamplingRates = {
        "00": 22050,
        "01": 24e3,
        10: 16e3,
        11: "reserved"
    },
    u.v25SamplingRates = {
        "00": 11025,
        "01": 12e3,
        10: 8e3,
        11: "reserved"
    },
    u.channelModes = {
        "00": "Stereo",
        "01": "Joint stereo (Stereo)",
        10: "Dual channel (Stereo)",
        11: "Single channel (Mono)"
    },
    u.mpegVersionDescription = {
        "00": "MPEG Version 2.5 (unofficial)",
        "01": "reserved",
        10: "MPEG Version 2 (ISO/IEC 13818-3)",
        11: "MPEG Version 1 (ISO/IEC 11172-3)"
    },
    u.layerDescription = {
        "00": "reserved",
        "01": "Layer III",
        10: "Layer II",
        11: "Layer I"
    },
    u.bitrateMap = {
        11: {
            "01": u.v1l3Bitrates,
            10: u.v1l2Bitrates,
            11: u.v1l1Bitrates
        },
        10: {
            "01": u.v2l3Bitrates,
            10: u.v2l2Bitrates,
            11: u.v2l1Bitrates
        }
    },
    u.samplingRateMap = {
        "00": u.v25SamplingRates,
        10: u.v2SamplingRates,
        11: u.v1SamplingRates
    },
    u.v1SampleLengths = {
        "01": 1152,
        10: 1152,
        11: 384
    },
    u.v2SampleLengths = {
        "01": 576,
        10: 1152,
        11: 384
    },
    u.sampleLengthMap = {
        "01": u.v2SampleLengths,
        10: u.v2SampleLengths,
        11: u.v1SampleLengths
    },
    u.wordSeqFromStr = function(e) {
        for (var r = e.length - 1, t = []; 0 <= r; --r)
            t[r] = e.charCodeAt(r);
        return t
    }
    ,
    u.seq = {
        id3: u.wordSeqFromStr("ID3"),
        xing: u.wordSeqFromStr("Xing"),
        info: u.wordSeqFromStr("Info")
    },
    u.noOp = function() {}
    ,
    u.unsynchsafe = function(e) {
        for (var r = 0, t = 2130706432; t; )
            r >>= 1,
            r |= e & t,
            t >>= 8;
        return r
    }
    ,
    u.isSeq = function(e, r, t) {
        for (var n = e.length - 1; 0 <= n; n--)
            if (e[n] !== r.getUint8(t + n))
                return !1;
        return !0
    }
    ,
    u.locateSeq = function(e, r, t, n) {
        for (var i = 0, a = n - e.length + 1; i < a; ++i)
            if (u.isSeq(e, r, t + i))
                return t + i;
        return -1
    }
    ,
    u.locateStrTrm = {
        iso: function(e, r, t) {
            return u.locateSeq([0], e, r, t)
        },
        ucs: function(e, r, t) {
            var n = u.locateSeq([0, 0], e, r, t);
            return -1 === n ? -1 : ((n - r) % 2 != 0 && ++n,
            n)
        }
    },
    u.readStr = {
        iso: function(e, r, t) {
            return String.fromCharCode.apply(null, new Uint8Array(e.buffer,r,t))
        },
        ucs: function(e, r, t) {
            65534 !== e.getUint16(r) && 65279 !== e.getUint16(r) || (r += 2,
            t -= 2);
            var n = e.buffer;
            return r % 2 == 1 && (n = n.slice(r, r + t),
            r = 0),
            String.fromCharCode.apply(null, new Uint16Array(n,r,t / 2))
        }
    },
    u.readTrmStr = {
        iso: function(e, r, t) {
            var n = u.locateStrTrm.iso(e, r, t);
            return -1 !== n && (t = n - r),
            u.readStr.iso(e, r, t)
        },
        ucs: function(e, r, t) {
            var n = u.locateStrTrm.ucs(e, r, t);
            return -1 !== n && (t = n - r),
            u.readStr.ucs(e, r, t)
        }
    },
    u.readFrameHeader = function(e, r) {
        if (r || (r = 0),
        e.byteLength - r <= 4)
            return null;
        if (255 !== e.getUint8(r))
            return null;
        var t = e.getUint8(r + 1);
        if (t < 224)
            return null;
        var n = d(t).substr(3, 2)
          , i = d(t).substr(5, 2)
          , a = {
            _section: {
                type: "frameHeader",
                byteLength: 4,
                offset: r
            },
            mpegAudioVersionBits: n,
            mpegAudioVersion: u.mpegVersionDescription[n],
            layerDescriptionBits: i,
            layerDescription: u.layerDescription[i],
            isProtected: 1 & t
        };
        if (a.protectionBit = a.isProtected ? "1" : "0",
        "reserved" === a.mpegAudioVersion)
            return null;
        if ("reserved" === a.layerDescription)
            return null;
        var o = e.getUint8(r + 2);
        if (o = d(o),
        a.bitrateBits = o.substr(0, 4),
        a.bitrate = u.bitrateMap[n][i][a.bitrateBits],
        "bad" === a.bitrate)
            return null;
        if (a.samplingRateBits = o.substr(4, 2),
        a.samplingRate = u.samplingRateMap[n][a.samplingRateBits],
        "reserved" === a.samplingRate)
            return null;
        a.frameIsPaddedBit = o.substr(6, 1),
        a.frameIsPadded = "1" === a.frameIsPaddedBit,
        a.framePadding = a.frameIsPadded ? 1 : 0,
        a.privateBit = o.substr(7, 1);
        var s = e.getUint8(r + 3);
        return a.channelModeBits = d(s).substr(0, 2),
        a.channelMode = u.channelModes[a.channelModeBits],
        a
    }
    ,
    u.readFrame = function(e, r, t) {
        r || (r = 0);
        var n = {
            _section: {
                type: "frame",
                offset: r
            },
            header: u.readFrameHeader(e, r)
        }
          , i = n.header;
        if (!i)
            return null;
        n._section.sampleLength = u.sampleLengthMap[i.mpegAudioVersionBits][i.layerDescriptionBits],
        n._section.byteLength = u.getFrameByteLength(i.bitrate, i.samplingRate, i.framePadding, i.mpegAudioVersionBits, i.layerDescriptionBits),
        n._section.nextFrameIndex = r + n._section.byteLength;
        var a = u.getXingOffset(i.mpegAudioVersionBits, i.channelModeBits);
        return u.isSeq(u.seq.xing, e, r + a) || u.isSeq(u.seq.info, e, r + a) ? null : t && !u.readFrameHeader(e, n._section.nextFrameIndex) ? null : n
    }
}),
function(r, e) {
    "use strict";
    if ("function" == typeof define && define.amd)
        return define(["exports", "./lib"], e);
    if ("object" == typeof exports)
        return e(exports, require("./lib"));
    var t = r.mp3XingParser;
    e(r.mp3XingParser = {
        noConflict: function() {
            var e = r.mp3XingParser;
            return r.mp3XingParser = t,
            (this.noConflict = function() {
                return e
            }
            ).call()
        }
    }, r.mp3ParserLib)
}(this, function(e, a) {
    "use strict";
    e.readXingTag = function(e, r) {
        r || (r = 0);
        var t = {
            _section: {
                type: "Xing",
                offset: r
            },
            header: a.readFrameHeader(e, r)
        }
          , n = t.header;
        if (!n)
            return null;
        var i = r + a.getXingOffset(n.mpegAudioVersionBits, n.channelModeBits);
        return e.byteLength < i + 4 ? null : (t.identifier = a.isSeq(a.seq.xing, e, i) ? "Xing" : a.isSeq(a.seq.info, e, i) && "Info",
        t.identifier ? (t._section.byteLength = a.getFrameByteLength(n.bitrate, n.samplingRate, n.framePadding, n.mpegAudioVersionBits, n.layerDescriptionBits),
        t._section.nextFrameIndex = r + t._section.byteLength,
        t) : null)
    }
}),
function(r, e) {
    "use strict";
    if ("function" == typeof define && define.amd)
        return define(["exports", "./lib"], e);
    if ("object" == typeof exports)
        return e(exports, require("./lib"));
    var t = r.mp3Id3v2Parser;
    e(r.mp3Id3v2Parser = {
        noConflict: function() {
            var e = r.mp3Id3v2Parser;
            return r.mp3Id3v2Parser = t,
            (this.noConflict = function() {
                return e
            }
            ).call()
        }
    }, r.mp3ParserLib)
}(this, function(s, u) {
    "use strict";
    var o = {
        AENC: "Audio encryption",
        APIC: "Attached picture",
        CHAP: "Chapter",
        COMM: "Comments",
        COMR: "Commercial frame",
        ENCR: "Encryption method registration",
        EQUA: "Equalization",
        ETCO: "Event timing codes",
        GEOB: "General encapsulated object",
        GRID: "Group identification registration",
        IPLS: "Involved people list",
        LINK: "Linked information",
        MCDI: "Music CD identifier",
        MLLT: "MPEG location lookup table",
        OWNE: "Ownership frame",
        PRIV: "Private frame",
        PCNT: "Play counter",
        POPM: "Popularimeter",
        POSS: "Position synchronisation frame",
        RBUF: "Recommended buffer size",
        RVAD: "Relative volume adjustment",
        RVRB: "Reverb",
        SYLT: "Synchronized lyric/text",
        SYTC: "Synchronized tempo codes",
        TALB: "Album/Movie/Show title",
        TBPM: "BPM (beats per minute)",
        TCOM: "Composer",
        TCON: "Content type",
        TCOP: "Copyright message",
        TDAT: "Date",
        TDLY: "Playlist delay",
        TENC: "Encoded by",
        TEXT: "Lyricist/Text writer",
        TFLT: "File type",
        TIME: "Time",
        TIT1: "Content group description",
        TIT2: "Title/songname/content description",
        TIT3: "Subtitle/Description refinement",
        TKEY: "Initial key",
        TLAN: "Language(s)",
        TLEN: "Length",
        TMED: "Media type",
        TOAL: "Original album/movie/show title",
        TOFN: "Original filename",
        TOLY: "Original lyricist(s)/text writer(s)",
        TOPE: "Original artist(s)/performer(s)",
        TORY: "Original release year",
        TOWN: "File owner/licensee",
        TPE1: "Lead performer(s)/Soloist(s)",
        TPE2: "Band/orchestra/accompaniment",
        TPE3: "Conductor/performer refinement",
        TPE4: "Interpreted, remixed, or otherwise modified by",
        TPOS: "Part of a set",
        TPUB: "Publisher",
        TRCK: "Track number/Position in set",
        TRDA: "Recording dates",
        TRSN: "Internet radio station name",
        TRSO: "Internet radio station owner",
        TSIZ: "Size",
        TSRC: "ISRC (international standard recording code)",
        TSSE: "Software/Hardware and settings used for encoding",
        TYER: "Year",
        TXXX: "User defined text information frame",
        UFID: "Unique file identifier",
        USER: "Terms of use",
        USLT: "Unsychronized lyric/text transcription",
        WCOM: "Commercial information",
        WCOP: "Copyright/Legal information",
        WOAF: "Official audio file webpage",
        WOAR: "Official artist/performer webpage",
        WOAS: "Official audio source webpage",
        WORS: "Official internet radio station homepage",
        WPAY: "Payment",
        WPUB: "Publishers official webpage",
        WXXX: "User defined URL link frame"
    }
      , d = {
        T: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            return n.value = u.readStr[0 === n.encoding ? "iso" : "ucs"](e, r + 1, t - 1),
            n
        },
        TXXX: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            if (t < 2)
                return n;
            var i = 0 === n.encoding ? "iso" : "ucs"
              , a = r + 1
              , o = u.locateStrTrm[i](e, a, t - 4);
            return -1 === o || (n.description = u.readStr[i](e, a, o - a),
            o += "ucs" == i ? 2 : 1,
            n.value = u.readStr[i](e, o, r + t - o)),
            n
        },
        W: function(e, r, t) {
            return {
                value: u.readStr.iso(e, r, t)
            }
        },
        WXXX: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            if (t < 2)
                return n;
            var i = 0 === n.encoding ? "iso" : "ucs"
              , a = r + 1
              , o = u.locateStrTrm[i](e, a, t - 4);
            return -1 === o || (n.description = u.readStr[i](e, a, o - a),
            o += "ucs" == i ? 2 : 1,
            n.value = u.readStr.iso(e, o, r + t - o)),
            n
        },
        COMM: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            if (t < 5)
                return n;
            var i = 0 === n.encoding ? "iso" : "ucs"
              , a = r + 4;
            n.language = u.readTrmStr.iso(e, r + 1, 3);
            var o = u.locateStrTrm[i](e, a, t - 4);
            return -1 === o || (n.description = u.readStr[i](e, a, o - a),
            o += "ucs" == i ? 2 : 1,
            n.text = u.readStr[i](e, o, r + t - o)),
            n
        },
        UFID: function(e, r, t) {
            var n = u.readTrmStr.iso(e, r, t);
            return {
                ownerIdentifier: n,
                identifier: new DataView(e.buffer,r + n.length + 1,t - n.length - 1)
            }
        },
        IPLS: function(e, r, t) {
            for (var n, i = {
                encoding: e.getUint8(r),
                values: []
            }, a = 0 === i.encoding ? "iso" : "ucs", o = r + 1; o < r + t; )
                -1 === (n = u.locateStrTrm[a](e, o, t - (o - r))) && (n = r + t),
                i.values.push(u.readStr[a](e, o, n - o)),
                o = n + ("ucs" == a ? 2 : 1);
            return i
        },
        USER: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            if (t < 5)
                return n;
            n.language = u.readTrmStr.iso(e, r + 1, 3);
            var i = r + 4
              , a = 0 === n.encoding ? "iso" : "ucs";
            return n.text = u.readStr[a](e, i, r + t - i),
            n
        },
        PRIV: function(e, r, t) {
            var n = u.readTrmStr.iso(e, r, t);
            return {
                ownerIdentifier: n,
                privateData: new DataView(e.buffer,r + n.length + 1,t - n.length - 1)
            }
        },
        PCNT: function(e, r, t) {
            return t < 4 ? {} : {
                counter: e.getUint32(r)
            }
        },
        POPM: function(e, r, t) {
            var n = {
                email: u.readTrmStr.iso(e, r, t)
            };
            return r += n.email.length + 1,
            t < 6 || (n.rating = e.getUint8(r),
            n.counter = e.getUint32(r + 1)),
            n
        },
        APIC: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            };
            if (t < 4)
                return n;
            var i, a, o = 0 === n.encoding ? "iso" : "ucs";
            return i = r + 1,
            -1 === (a = u.locateStrTrm.iso(e, i, t - 1)) ? n : (n.mimeType = u.readStr.iso(e, i, a - i),
            i = a + 1,
            n.pictureType = e.getUint8(i),
            i += 1,
            -1 === (a = u.locateStrTrm[o](e, i, r + t - i)) || (n.description = u.readStr[o](e, i, a - i),
            i = a + ("ucs" == o ? 2 : 1),
            n.pictureData = new DataView(e.buffer,i,r + t - i)),
            n)
        },
        CHAP: function(e, r, t) {
            var n = {
                encoding: e.getUint8(r)
            }
              , i = u.locateStrTrm.iso(e, r, t - 1);
            if (-1 === i)
                return n;
            n.id = u.readStr.iso(e, r, i - r),
            n.startTime = e.getUint32(i + 1),
            n.endTime = e.getUint32(i + 5),
            n.startOffset = e.getUint32(i + 9),
            n.endOffset = e.getUint32(i + 13);
            var a = i + 17;
            for (n.frames = []; a < r + t; ) {
                var o = s.readId3v2TagFrame(e, a);
                n.frames.push(o),
                a += o.header.size + 10
            }
            return n
        }
    };
    s.readId3v2TagFrame = function(e, r) {
        var t = {
            header: {
                id: u.readStr.iso(e, r, 4),
                size: e.getUint32(r + 4),
                flagsOctet1: e.getUint8(r + 8),
                flagsOctet2: e.getUint8(r + 9)
            }
        };
        if (t.header.size < 1)
            return t;
        var n, i, a = (n = d,
        "TXXX" === (i = t.header.id) ? n.TXXX : "T" === i.charAt(0) ? n.T : "WXXX" === i ? n.WXXX : "W" === i.charAt(0) ? n.W : "COMM" === i || "USLT" === i ? n.COMM : n[i] || u.noOp);
        return t.name = o[t.header.id],
        t.content = a(e, r + 10, t.header.size),
        t
    }
    ,
    s.readId3v2Tag = function(e, r) {
        if (r || (r = 0),
        e.byteLength - r < 10)
            return null;
        if (!u.isSeq(u.seq.id3, e, r))
            return null;
        var t = e.getUint8(r + 5)
          , n = {
            _section: {
                type: "ID3v2",
                offset: r
            },
            header: {
                majorVersion: e.getUint8(r + 3),
                minorRevision: e.getUint8(r + 4),
                flagsOctet: t,
                unsynchronisationFlag: 128 == (128 & t),
                extendedHeaderFlag: 64 == (64 & t),
                experimentalIndicatorFlag: 32 == (32 & t),
                size: u.unsynchsafe(e.getUint32(r + 6))
            },
            frames: []
        };
        n._section.byteLength = n.header.size + 10;
        var i, a = r + n._section.byteLength;
        if (3 !== n.header.majorVersion)
            return n;
        for (r += 10; r < a && 0 !== e.getUint32(r) && (i = s.readId3v2TagFrame(e, r)); )
            n.frames.push(i),
            r += i.header.size + 10;
        return n
    }
}),
function(r, e) {
    "use strict";
    if ("function" == typeof define && define.amd)
        return define(["exports", "./lib/lib", "./lib/id3v2", "./lib/xing"], e);
    if ("object" == typeof exports)
        return e(exports, require("./lib/lib"), require("./lib/id3v2"), require("./lib/xing"));
    var t = r.mp3Parser;
    e(r.mp3Parser = {
        noConflict: function() {
            var e = r.mp3Parser;
            return r.mp3Parser = t,
            (this.noConflict = function() {
                return e
            }
            ).call()
        }
    }, r.mp3ParserLib, r.mp3Id3v2Parser, r.mp3XingParser)
}(this, function(d, n, t, i) {
    "use strict";
    d.readFrameHeader = function(e, r) {
        return n.readFrameHeader(e, r)
    }
    ,
    d.readFrame = function(e, r, t) {
        return n.readFrame(e, r, t)
    }
    ,
    d.readLastFrame = function(e, r, t) {
        r || (r = e.byteLength - 1);
        for (var n = null; 0 <= r; --r)
            if (255 === e.getUint8(r) && (n = d.readFrame(e, r, t)))
                return n;
        return null
    }
    ,
    d.readId3v2Tag = function(e, r) {
        return t.readId3v2Tag(e, r)
    }
    ,
    d.readXingTag = function(e, r) {
        return i.readXingTag(e, r)
    }
    ,
    d.readTags = function(e, r) {
        r || (r = 0);
        for (var t = [], n = null, i = !1, a = e.byteLength, o = [d.readId3v2Tag, d.readXingTag, d.readFrame], s = o.length; r < a && !i; ++r)
            for (var u = 0; u < s; ++u)
                if (n = o[u](e, r)) {
                    if (t.push(n),
                    r += n._section.byteLength,
                    "frame" === n._section.type) {
                        i = !0;
                        break
                    }
                    u = -1
                }
        return t
    }
});
